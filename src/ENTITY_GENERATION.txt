#######
# How it will look after generation:
####
// Prelude
use crate::number::{Readable, Writeable, LimitedNumber};
use num_bigint::BigUint;
fn one() -> BigUint {
    BigUint::new(vec![1])
}

// "struct"
struct Blah {
    a: A,
    b: B,
}

impl Blah {
    pub fn encode(&self) -> impl Iterator<Item = LimitedNumber> {
        self.
    }
}

// "enum"
enum Bleh {

}

// "sequence"
struct Bloh {
    pub items: Vec<A>,
}

impl Bloh {
    pub fn exclusive_upper_limit() -> ExclusiveUpperLimit {
        A::exclusive_upper_limit().increase(&one())
    }
    pub fn encode(&self, writer: &mut impl Writeable) {
        writer.write(LimitedNumber::new(self.exclusive_upper_limit(), ExclusiveUpperLimit::new(BigUint::ZERO).unwrap()));
        struct IncreasingWriter<'a> {
            source: &'a mut impl Writeable,
        }
        impl<'a> Writeable for IncreasingWriter<'a> {
            fn write(&mut self, limited_number: &LimitedNumber) {
                self.source.write(&limited_number.increase(&one()));
            }
        }
        let writer = IncreasingWriter {
            source: writer,
        };
        for item in &self.items {
            item.encode(writer);
        }
    }
    pub fn decode(mut current: BigUint, reader: &mut impl Readable) -> Self {
        let items = Vec::new();
        struct DecreasingReader<'a> {
            source: &'a mut impl Readable,
        }
        impl<'a> Readable for DecreasingReader<'a> {
            fn read(&mut self, exclusive_upper_limit: &ExclusiveUpperLimit) -> BigUint {
                exclusive_upper_limit
            }
        }
        loop {
            let value = reader.read(&self.exclusive_upper_limit());
            if value == BigUint::ZERO {
                break;
            } else {
                A::decode()
            }
        }
        Self { items }
    }
}
